#!/usr/bin/perl -w

use strict;

use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Find;
use Getopt::Long;

use constant S3_BUCKET => 's3://raw-track-data';
use constant LOG_BASE  => '/var/log/track';

our %MON = (jan => 1, feb => 2, mar => 3, apr => 4,  may => 5,  jun => 6,
			jul => 7, aug => 8, sep => 9, oct => 10, nov => 11, dec => 12);

my (@file, $period, $keep, $rsync_dir, $s3_bucket, $verbose, $test);
GetOptions('file=s'      => \@file,
		   'period=s'    => \$period,
		   'keep=s'      => \$keep,
		   'rsync-dir=s' => \$rsync_dir,
		   's3-bucket=s' => \$s3_bucket,
		   'verbose'     => \$verbose,
		   'test'        => \$test,
		  );

die "Argument --file required\n" unless @file;
die "Argument --period required\n" unless $period;

print STDERR "\n== TEST MODE ==\n\n" if $test;

# Keep 3 days of files by default
$keep ||= 3;

$s3_bucket ||= S3_BUCKET();

our $UX_TS = time;

# Get a time stamp that is locked to increments of $period minutes
$UX_TS -= $UX_TS%($period*60);

our @TS = localtime($UX_TS);
$TS[5] += 1900;
$TS[4]++;

our @CLEANUP_TS = localtime($UX_TS - ($keep*24*60*60));
$CLEANUP_TS[5] += 1900;
$CLEANUP_TS[4]++;

my @zips;
foreach my $f (@file) {
	if (! -e $f) {
		debug("Skipping file '$f': does not exist\n");
		next;
	}
	my $zip = rotate($f);
	push @zips, $zip if $zip;
}

# Only HUP the server if we rotated anything
if (@zips) {
	debug("Sending HUP to rsyslog\n");
	if (! $test) {
		my $pid = `cat /var/run/rsyslogd.pid`;
		chomp($pid);
		system("kill -HUP $pid");
	}
}


# Zip any/all the files rotated above
foreach my $sub (@zips) {
	$sub->();
}

# Cleanup anything older than $period days
foreach my $f (@file) {
	cleanup($f, $period);
}

# Rsync the data to a permanent store
if ($rsync_dir) {
	foreach my $f (@file) {
		my ($base, $name) = $f =~ m!^(.+)/([^/]+)$!;
		die "Can't determine base directory from '$f'\n" unless $base && $name; 

		debug("Rsyncing '$base' to '$rsync_dir'\n");

		# Rsync everything from the directory the rotate file is in except the rotate file
		my $cmd = "/usr/bin/rsync -Pavq --exclude '$name' $base $rsync_dir";

		system($cmd) unless $test;
	}
}

if ($s3_bucket) {
	foreach my $f (@file) {
		my ($base, $name) = $f =~ m!^(.+)/([^/]+)$!;
		die "Can't determine base directory from '$f'\n" unless $base && $name; 

		debug("Syncing '$base' to '$s3_bucket'\n");

		s3_sync($s3_bucket, $base);
	}
}

debug("Finished\n");

################################################################################

sub rotate {
	my ($file) = @_;
	my ($base, $file_name) = $file =~ m!^(.+)/([^/]+)$!;

	my $date_dir = sprintf("%04d/%02d/%02d", @TS[5,4,3]);
	my $new_name = sprintf("%s-%02d-%02d.%s",
							$file_name, @TS[2,1], $UX_TS);
	my $new_full = $base.'/'.$date_dir.'/'.$new_name;

	# Create the directory, if necessary
	make_path($base.'/'.$date_dir);

	# Determine if the last log has been rotated or not
	if (!-e $new_full && !-e $new_full.'.gz') {
		debug("Rotating '$file' to '$new_full'\n");
		if (! $test) {
			rename($file, $new_full)
				or die "Failed to copy '$file' to '$new_full': $!\n";
		}

		return sub {
			my (@lines_for_prior, @lines_for_curr, @lines_from_next, @lines_for_next);

			# Before continuing, make sure nobody has this file open!
			while (`fuser $new_full`) {
				debug("File to zip still open, waiting ... \n");
				sleep(1);
			}
				
			# Sort the lines for the current file and make sure only files in our time
			# period are included
			sort_lines($new_full, \@lines_for_prior, \@lines_for_curr, \@lines_for_next);

			# Find any lines in the file currently being written to see if there's any
			# for this period that have bled over.
			pull_next_lines($file, \@lines_from_next);

			debug(sprintf(qq{Time alignment:
- Found %d line(s) for the prior period
- Found %d line(s) for the next period
- Found %d line(s) from the next period that should be in this zip
},
						  scalar @lines_for_prior, scalar @lines_for_next, scalar @lines_from_next));

			# Get the previous date directory in case it happens to be for the previous day
			my @ts_prev = localtime($UX_TS-15*60);
			$ts_prev[5] += 1900;
			$ts_prev[4]++;
			my $prev_date_dir = sprintf("%04d/%02d/%02d", @ts_prev[5,4,3]);

			my $for_next = "$base/$prev_date_dir/for_next.log";

			debug("Gzip'ping '$new_name'\n");
			if (! $test) {
				# Add to the for_next file with just the lines that begin in this time period
				open(FH, '>>', $for_next) or die "Can't write to '$for_next': $!\n";
				foreach my $line (@lines_for_curr) {
					print FH $line;
				}
				close(FH);

				# Rename this to be the current log file before zipping
				rename($for_next, $new_full) or die "Can't rename '$for_next' to '$new_full': $!\n";

				if (system("gzip $new_full") != 0) {
					die "Gziping '$new_full' failed\n";
				}

				# Create the next "for_next" file
				open(FH, '>', $for_next) or die "Can't open file '$for_next': $!\n";
				foreach my $line (@lines_for_next) {
					print FH $line;
				}
				close(FH);
			}
		}
	} else {
		debug("File '$file' already rotated; doing nothing\n");
	}

	return;
}

sub sort_lines {
	my ($file, $for_prior, $for_curr, $for_next) = @_;
	our @PRIOR_TS = localtime($UX_TS-(15*60));
	$PRIOR_TS[5] += 1900;
	$PRIOR_TS[4]++;

	my $low_date  = sprintf("%02d-%02d %02d:%02d:%02d", @PRIOR_TS[4,3,2,1,0]);
	my $high_date = sprintf("%02d-%02d %02d:%02d:%02d", @TS[4,3,2,1,0]);

	# It may take some time for rsyslog to create the new file after a HUP
	wait_for_file($file) or die "New log file '$file' not recreated\n";

	# Mar 27 00:00:01 
	open(FH, $file) or die "Couldn't open '$file': $!\n";
	while (my $line = <FH>) {
		my ($month, $day, $remainder) = $line =~ m!^(\S+)\s+(\d+)\s+(\d+:\d+:\d+)!;
		$month = sprintf("%02d", $MON{lc($month)});
		$day   = sprintf("%02d", $day);

		# In the event that the date is weird, just keep it in the file
		unless ($month && $remainder) {
			push @$for_curr, $line;
			next;
		}

		my $line_date = $month.'-'.$day.' '.$remainder;
		if ($line_date lt $low_date) {
			push @$for_prior, $line;
		} elsif ($line_date ge $high_date) {
			push @$for_next, $line;
		} else {
			push @$for_curr, $line;
		}
	}
	close(FH);
}

sub pull_next_lines {
	my ($file, $from_next) = @_;
	my $low_date  = sprintf("%02d-%02d %02d:%02d:%02d", @TS[4,3,2,1,0]);

	# It may take some time for rsyslog to create the new file after a HUP
	if (!wait_for_file($file)) {
		debug("New log file '$file' not recreated\n");
		return;
	}

	open(FH, $file) or die "Couldn't open '$file': $!\n";
	while (my $line = <FH>) {
		my ($month, $remainder) = $line =~ m!^(\S+)\s+(\d+\s+\d+:\d+:\d+)!;
		$month = sprintf("%02d", $MON{lc($month)});

		next unless $month && $remainder;

		my $line_date = $month.'-'.$remainder;
		push @$from_next, $line if $line_date lt $low_date;
	}
	close(FH);

	return 1;
}

sub cleanup {
	my ($f, $period) = @_;
	my $base = $f;
	$base =~ s!/[^/]+$!!;

	debug("Pruning older files\n");

	find(sub {
			# Look for the dated directories, not files.
			my ($Y, $M, $D) = $File::Find::name =~ m!^$base/(\d{4})/(\d{2})/(\d{2})$!;
			return unless $Y && $M && $D;

			if (($Y < $CLEANUP_TS[5]) ||
				($Y == $CLEANUP_TS[5] && $M < $CLEANUP_TS[4]) ||
				($Y == $CLEANUP_TS[5] && $M == $CLEANUP_TS[4] && $D < $CLEANUP_TS[3])) {

				debug("-- removing '$File::Find::name'\n");
				$File::Find::prune = 1;
				if (! $test) {
					remove_tree($File::Find::name);
				}
			}
		}, $base);
}

sub s3_sync {
	my ($s3_bucket, $base) = @_;
	my $rel_base = $base;
	my $log_base = LOG_BASE();
	$rel_base =~ s!^$log_base/!!;

	my $now = time;
	my $today = day_dir($now);
	my $yest  = day_dir($now - 60*60*24);

	foreach my $subdir ($today, $yest) {
		my $local_dir  = "$base/$subdir/";
		my $remote_dir = "$s3_bucket/$rel_base/$subdir/";

		debug("-- syncing subdir '$local_dir' to '$remote_dir'\n");

		system("s3cmd sync $local_dir $remote_dir");
	}
}

sub day_dir {
	my ($time) = @_;
	my @day = localtime($time);
	$day[5] += 1900;
	$day[4]++;

	return sprintf("%04d/%02d/%02d", @day[5,4,3]);
}

sub wait_for_file {
	my ($file) = @_;
	my $sleep_secs = 2;

	my $tries = 3;
	while ($tries && !-e $file) {
		debug("File $file not ready, sleeping $sleep_secs ...\n");
		sleep $sleep_secs;

		$sleep_secs *= 2;
		$tries--;
	}
	
	return $tries;
}

sub debug {
	my ($msg) = @_;
	return unless $verbose;
	print STDERR localtime()." ($$): $msg";
}
