#!/usr/bin/perl -w

use strict;

use FindBin qw/$Bin/;
use lib "$Bin/../../lib";

use Capture::Tiny ':all';
use Getopt::Long;
use JSON qw( decode_json );
use Wikia::DW::Common;

my $queue;

GetOptions( 'queue:s' => \$queue );

my $h = `hostname`;
chomp($h);
my $worker_id = "$h:$$";

exit unless register_worker($queue, $worker_id) > 0;

# Main Event Loop
while (queue_needs_workers($queue)) {

    my $db_jobs = Wikia::DW::Common::statsdb_arrayref(
       "SELECT j.job_id,
               j.job_class,
               j.job_params,
               j.job_period_id,
               j.job_lag,
               j.job_status,
               j.job_begin_time,
               j.job_end_time
          FROM statsdb_etl.etl_jobs j
         WHERE j.job_status = 'ENABLED'
           AND j.job_queue = '$queue'",
        'hash'
    );

    for my $j (@$db_jobs) {

        $j->{dependencies} = [ { job_id => 0 } ];  # Initialized with fake job_id zero so available_job_times query is simpler below

        my $db_depends = Wikia::DW::Common::statsdb_arrayref(
           "SELECT d.job_id,
                   d.job_class,
                   d.job_params,
                   d.job_period_id,
                   d.job_lag,
                   d.job_status,
                   d.job_begin_time,
                   d.job_end_time
              FROM statsdb_etl.etl_job_dependencies jd
              JOIN statsdb_etl.etl_jobs d
                ON d.job_id = jd.depends_job_id
             WHERE jd.job_id = $j->{job_id}
             ORDER BY d.job_id",
            'hash'
        );

        $j->{dependency_ids} = join(',', map { $_->{job_id} } @$db_depends);

        # Get a database connection for custom isolation and autocommit settings
        my $statsdb_dbh = Wikia::DW::Common::statsdb;

        $statsdb_dbh->do('SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED');
        $statsdb_dbh->do('SET AUTOCOMMIT=1');

        my $available_job_times = $statsdb_dbh->selectall_arrayref(
           "SELECT pt.period_id,
                   pt.time_id,
                   pt.begin_time,
                   pt.end_time,
                   pt.epoch_time_id,
                   pt.epoch_begin_time,
                   pt.epoch_end_time,
                   IFNULL(MIN(dep_status.last_executed_at), now()) AS last_executed_at
              FROM statsdb_etl.etl_period_times pt
              LEFT JOIN statsdb_etl.etl_job_time_status job_status 
                ON job_status.job_id  = $j->{job_id}
               AND job_status.time_id = pt.time_id
              LEFT JOIN statsdb_etl.etl_job_time_status dep_status 
                ON dep_status.job_id IN ($j->{dependency_ids})
               AND dep_status.time_id = pt.time_id
               AND dep_status.status = 'COMPLETE'
             WHERE pt.period_id = $j->{job_period_id}
               AND pt.time_id >= TIMESTAMP('$j->{job_begin_time}')
               AND pt.time_id <  LEAST(DATE_SUB(now(), INTERVAL $j->{job_lag} MINUTE), TIMESTAMP('$j->{job_end_time}'))
               AND (job_status.status IS NULL OR job_status.status != 'FAILED')
             GROUP BY pt.time_id
            HAVING COUNT(CASE WHEN dep_status.last_executed_at IS NOT NULL THEN 1 ELSE null END) = COUNT(1)
               AND COUNT(CASE WHEN dep_status.last_executed_at > IFNULL(job_status.last_executed_at, TIMESTAMP('1970-01-01'))
                              THEN 1 ELSE null END) > 0
             LIMIT 5",
            { Slice => {} } # Note: this makes the resulting row references be hashes
        );

        foreach my $aj (@$available_job_times) {
            my $locked = 0;  # No locked job yet

            eval {
                $locked = $statsdb_dbh->do(
                   "INSERT INTO statsdb_etl.etl_job_time_status (
                        job_id,
                        time_id,
                        last_executed_at,
                        status,
                        duration,
                        worker_id,
                        stdout,
                        stderr
                    ) VALUES (
                        $j->{job_id},
                        TIMESTAMP('$aj->{time_id}'),
                        null,
                        'RUNNING',
                        null,
                        '$worker_id',
                        null,
                        null
                    )"
                );  
            };
            if (my $err = $@) {
                if ($err =~ m/Duplicate entry/) {
                    $locked = $statsdb_dbh->do(
                       "UPDATE statsdb_etl.etl_job_time_status
                           SET status    = 'RUNNING',
                               duration  = null,
                               worker_id = '$worker_id',
                               stdout    = null,
                               stderr    = null
                         WHERE job_id  = $j->{job_id}
                           AND time_id = TIMESTAMP('$aj->{time_id}')
                           AND worker_id IS NULL
                           AND status != 'FAILED'"
                    );  
                }
            }
            if ($locked == 1) {
                # This worker got the job; get to work!
                my ($stdout, $stderr, $result) = ('','','');
                eval {
                    my $pkg = "Wikia::DW::ETL::Job::$j->{job_class}";
                    eval "use $pkg";

                    my $job = $pkg->new();

                    my $params = decode_json( $j->{job_params} );

                    @{$j}{keys %$aj}     = values %$aj;
                    @{$j}{keys %$params} = values %$params;

                    ($stdout, $stderr, $result) = capture {
                        return scalar $job->process( $j );
                    };
                };
                if (my $err = $@) {
                    $statsdb_dbh->do(
                       "UPDATE statsdb_etl.etl_job_time_status
                           SET last_executed_at = now(),
                               status    = 'FAILED',
                               duration  = null,
                               worker_id = null,
                               stdout    = $stdout,
                               stderr    = $stderr
                         WHERE job_id    = $j->{job_id}
                           AND time_id   = TIMESTAMP('$aj->{time_id}')
                           AND worker_id = '$worker_id'
                           AND status    = 'RUNNING'"
                    );
                } else {
                    $statsdb_dbh->do(
                       "UPDATE statsdb_etl.etl_job_time_status
                           SET last_executed_at = CASE WHEN '$stderr' = '' THEN TIMESTAMP('$aj->{last_executed_at}') ELSE now() END
                               status           = CASE WHEN '$stderr' = '' THEN 'COMPLETE' ELSE 'FAILED' END,
                               duration  = null,
                               worker_id = null,
                               stdout    = $stdout,
                               stderr    = $stderr
                         WHERE job_id    = $j->{job_id}
                           AND time_id   = TIMESTAMP('$aj->{time_id}')
                           AND worker_id = '$worker_id'
                           AND status    = 'RUNNING'"
                    );
                }
            } # if ($locked == 1) block end
        } # available_job_times loop
        $statsdb_dbh->disconnect;
    }

    sleep(1);

} # Main Event Loop (runs while queue is UP and has a need for workers)

unregister_worker($queue, $worker_id);


sub queue_needs_workers {
    my $queue = shift;
    return Wikia::DW::Common::statsdb_value(
       "SELECT CASE WHEN MAX(q.status) = 'UP' AND COUNT(qw.worker_id) <= MAX(q.workers) THEN 1 ELSE 0 END
          FROM statsdb_etl.etl_job_queues q
          LEFT JOIN statsdb_etl.etl_job_queue_workers qw
            ON qw.queue = q.queue
         WHERE q.queue = '$queue'
         GROUP BY q.queue"
    );
}

sub register_worker {
    my ($queue, $worker_id) = @_;

    my $statsdb_dbh = Wikia::DW::Common::statsdb;

    $statsdb_dbh->do('SET AUTOCOMMIT=1');

    my $workers = $statsdb_dbh->do(
       "INSERT INTO statsdb_etl.etl_job_queue_workers (
            queue,
            worker_id,
            created_at
        )
        SELECT '$queue'     AS queue,
               '$worker_id' AS worker_id,
               now()        AS created_at
          FROM statsdb_etl.etl_job_queues q
          LEFT JOIN statsdb_etl.etl_job_queue_workers qw
            ON qw.queue = q.queue
         WHERE q.queue = '$queue'
         GROUP BY q.queue
        HAVING COUNT(qw.worker_id) < MAX(q.workers)"
    );

    $statsdb_dbh->disconnect;
    return $workers;
}

sub unregister_worker {
    my ($queue, $worker_id) = @_;

    my $statsdb_dbh = Wikia::DW::Common::statsdb;

    $statsdb_dbh->do(
       "UPDATE statsdb_etl.etl_job_time_status
           SET worker_id = null,
               status    = 'FAILED'
         WHERE queue     = '$queue'
           AND worker_id = '$worker_id'"
    );

    $statsdb_dbh->do(
       "DELETE FROM statsdb_etl.etl_job_queue_workers
         WHERE queue     = '$queue'
           AND worker_id = '$worker_id'"
    );

    $statsdb_dbh->do('COMMIT');

    $statsdb_dbh->disconnect;
}

$SIG{'INT'} = sub {
    unregister_worker($queue, $worker_id);
    exit();
};

$SIG{'KILL'} = sub {
    unregister_worker($queue, $worker_id);
    exit();
};

